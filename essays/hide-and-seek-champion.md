---
layout: essay
type: essay
title: Hide and Seek Champion Since 1958 -The Semicolon
date: 2017-08-26
labels:
  - Software Engineering
  - Learning
---


As I learn new coding languages, I make internal notes in my head on how they are similar/dissimilar to the other languages I am familiar with. I think the dissimilarities list is never ending when comparing languages like Java and Python. As I learn Javascript, I realize the list of dissimilarities between Java and Javascript shortens while the similarities list lengthens (which is quite obvious given their names). That's not to say these are pro/con lists. Each language has its good qualities as well as its bad. For example, Python is a scripting language, so it is very easy to read and used as an introduction to computer science. However, it is slower and datatypes are introduced, which is an issue when using other languages. Javascript, on the other hand, is a more well known language and used in a significant amount of web development. However, it can get extremely complex and hard to sort through large amounts of code. As of right now, I personally do not have a preference as to which is better. 

However, there is one reoccuring theme I see in all my comparisons, and it has absolutely nothing to do with what language is being used: user error. There are many times when I think I have completed my code and try to run it, just to be shown a list of errors. And this has happened in every single language I have written in. At first I think, "Can I please just give up?". However, after digging around a bit, I find that I just missed a semicolon (at least in Java/Javascript), or I left out an ending parenthesis somewhere. This is why I don't have a preference as to which language I use. I know each coder has his/her strengths which lead them to prefer a specific language and each language is sometimes used for its specific purpose (HTML/CSS for web design). But when push comes to shove, there is only one major thing that computer scientist need to know how to do- problem solve. So much of coding is critical thinking and problem solving - understanding the problem, sorting it into individual components and fixing each component, and then sewing everything back together to reach the end goal. Every computer scientist has made the mistake of slipping up on the "obvious" aspects like spelling and punctuation. This isn't to say one day I won't have a preferential language. Depending on what track I decide to specialize in will more than likely influence the language I will prefer. 

Which brings me to my next point of using WOD (workouts of the day) to learn. I think they are a fabulous idea, if they do not have to run perfectly every time. Under a time crunch, people get stressed, which generally leads them to make mistakes more frequently. Now the student is not only stressed about solving the problem, but also making sure they didn't forget any semicolons, which is almost inevitable. Now, I understand that there are plenty of situations in the "real world" where time crunches happen and people need to know how to work under pressure. However, in a learning environment, I think its more important to learn how to problem solve and think critically in a time crunch than learn how to type perfect code in a time crunch. Furthermore, I think a lot of learning how to code is by trying one thing, realizing it doesn't work, and figuring out a new solution. In real life, the first solution that comes to mind won't always work like it's supposed to. Sometimes the code will be completely wrong and you will in fact have to start over. However, in WOD's, there isn't enough time to do so. You have to understand how to complete the program the right way the first time. Which is good in practice, but ultimately unrealistic to expect 100% of the time, which I think has been shown by the outcomes of the WOD's thus far.

 Overall, learning Javascript has been very insightful and I am interested in learning its further uses. However, my main focus will be continually improving my critical thinking, analyzing, and problem solving skills because I can apply those skills to any new language I learn within computer science.

